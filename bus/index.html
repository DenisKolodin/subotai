<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `bus` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, bus">

    <title>bus - Rust</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'></p><script>window.sidebarCurrent = {name: 'bus', ty: 'mod', relpath: '../'};</script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Crate <a class='mod' href=''>bus</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-0' class='srclink' href='../src/bus/lib.rs.html#1-791' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>Bus provides a lock-free, bounded, single-producer, multi-consumer, broadcast channel.</p>

<p>It uses a circular buffer and atomic instructions to implement a lock-free single-producer,
multi-consumer channel. The interface is similar to that of the <code>std::sync::mpsc</code> channels,
except that multiple consumers (readers of the channel) can be produced, whereas only a single
sender can exist. Furthermore, in contrast to most multi-consumer FIFO queues, bus is
<em>broadcast</em>; every send goes to every consumer.</p>

<p>I haven&#39;t seen this particular implementation in literature (some extra bookkeeping is
necessary to allow multiple consumers), but a lot of related reading can be found in Ross
Bencina&#39;s blog post <a href="http://www.rossbencina.com/code/lockfree">&quot;Some notes on lock-free and wait-free
algorithms&quot;</a>.</p>

<p>Bus achieves broadcast by cloning the element in question, which is why <code>T</code> must implement
<code>Clone</code>. However, Bus is clever about only cloning when necessary. Specifically, the last
consumer to see a given value will move it instead of cloning, which means no cloning is
happening for the single-consumer case. For cases where cloning is expensive, <code>Arc</code> should be
used instead.</p>

<p>In a single-producer, single-consumer setup (which is the only one that Bus and
<code>mpsc::sync_channel</code> both support), Bus gets ~2x the performance of <code>mpsc::sync_channel</code> on
my machine. YMMV. You can check your performance on Nightly using</p>

<pre><code class="language-console">$ cargo bench --features bench
</code></pre>

<p>To see multi-consumer results, run the benchmark utility instead (should work on stable too)</p>

<pre><code class="language-console">$ cargo build --bin bench --release
$ target/release/bench
</code></pre>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<p>Single-send, multi-consumer example</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>bus</span>::<span class='ident'>Bus</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>bus</span> <span class='op'>=</span> <span class='ident'>Bus</span>::<span class='ident'>new</span>(<span class='number'>10</span>);
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rx1</span> <span class='op'>=</span> <span class='ident'>bus</span>.<span class='ident'>add_rx</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rx2</span> <span class='op'>=</span> <span class='ident'>bus</span>.<span class='ident'>add_rx</span>();

<span class='ident'>bus</span>.<span class='ident'>broadcast</span>(<span class='string'>&quot;Hello&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>rx1</span>.<span class='ident'>recv</span>(), <span class='prelude-val'>Ok</span>(<span class='string'>&quot;Hello&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>rx2</span>.<span class='ident'>recv</span>(), <span class='prelude-val'>Ok</span>(<span class='string'>&quot;Hello&quot;</span>));<a class='test-arrow' target='_blank' href=''>Run</a></pre>

<p>Multi-send, multi-consumer example</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>bus</span>::<span class='ident'>Bus</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>bus</span> <span class='op'>=</span> <span class='ident'>Bus</span>::<span class='ident'>new</span>(<span class='number'>10</span>);
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rx1</span> <span class='op'>=</span> <span class='ident'>bus</span>.<span class='ident'>add_rx</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rx2</span> <span class='op'>=</span> <span class='ident'>bus</span>.<span class='ident'>add_rx</span>();

<span class='comment'>// start a thread that sends 1..100</span>
<span class='kw'>let</span> <span class='ident'>j</span> <span class='op'>=</span> <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
    <span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='number'>1</span>..<span class='number'>100</span> {
        <span class='ident'>bus</span>.<span class='ident'>broadcast</span>(<span class='ident'>i</span>);
    }
});

<span class='comment'>// every value should be received by both receivers</span>
<span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='number'>1</span>..<span class='number'>100</span> {
    <span class='comment'>// rx1</span>
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>rx1</span>.<span class='ident'>recv</span>(), <span class='prelude-val'>Ok</span>(<span class='ident'>i</span>));
    <span class='comment'>// and rx2</span>
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>rx2</span>.<span class='ident'>recv</span>(), <span class='prelude-val'>Ok</span>(<span class='ident'>i</span>));
}

<span class='ident'>j</span>.<span class='ident'>join</span>().<span class='ident'>unwrap</span>();<a class='test-arrow' target='_blank' href=''>Run</a></pre>

<p>Many-to-many channel using a dispatcher</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>bus</span>::<span class='ident'>Bus</span>;

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::<span class='ident'>mpsc</span>;

<span class='comment'>// set up fan-in</span>
<span class='kw'>let</span> (<span class='ident'>tx1</span>, <span class='ident'>mix_rx</span>) <span class='op'>=</span> <span class='ident'>mpsc</span>::<span class='ident'>sync_channel</span>(<span class='number'>100</span>);
<span class='kw'>let</span> <span class='ident'>tx2</span> <span class='op'>=</span> <span class='ident'>tx1</span>.<span class='ident'>clone</span>();
<span class='comment'>// set up fan-out</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>mix_tx</span> <span class='op'>=</span> <span class='ident'>Bus</span>::<span class='ident'>new</span>(<span class='number'>100</span>);
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rx1</span> <span class='op'>=</span> <span class='ident'>mix_tx</span>.<span class='ident'>add_rx</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rx2</span> <span class='op'>=</span> <span class='ident'>mix_tx</span>.<span class='ident'>add_rx</span>();
<span class='comment'>// start dispatcher</span>
<span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
    <span class='kw'>for</span> <span class='ident'>m</span> <span class='kw'>in</span> <span class='ident'>mix_rx</span>.<span class='ident'>iter</span>() {
        <span class='ident'>mix_tx</span>.<span class='ident'>broadcast</span>(<span class='ident'>m</span>);
    }
});

<span class='comment'>// sends on tx1 are received ...</span>
<span class='ident'>tx1</span>.<span class='ident'>send</span>(<span class='string'>&quot;Hello&quot;</span>).<span class='ident'>unwrap</span>();

<span class='comment'>// ... by both receiver rx1 ...</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>rx1</span>.<span class='ident'>recv</span>(), <span class='prelude-val'>Ok</span>(<span class='string'>&quot;Hello&quot;</span>));
<span class='comment'>// ... and receiver rx2</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>rx2</span>.<span class='ident'>recv</span>(), <span class='prelude-val'>Ok</span>(<span class='string'>&quot;Hello&quot;</span>));

<span class='comment'>// same with sends on tx2</span>
<span class='ident'>tx2</span>.<span class='ident'>send</span>(<span class='string'>&quot;world&quot;</span>).<span class='ident'>unwrap</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>rx1</span>.<span class='ident'>recv</span>(), <span class='prelude-val'>Ok</span>(<span class='string'>&quot;world&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>rx2</span>.<span class='ident'>recv</span>(), <span class='prelude-val'>Ok</span>(<span class='string'>&quot;world&quot;</span>));<a class='test-arrow' target='_blank' href=''>Run</a></pre>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.Bus.html'
                                  title='bus::Bus'>Bus</a></td>
                           <td class='docblock-short'>
                                <p>Bus is the main interconnect for broadcast messages.
It can be used to send broadcast messages, or to connect additional consumers.
When the Bus is dropped, receivers will continue receiving any outstanding broadcast messages
they would have received if the bus were not dropped. After all those messages have been
received, any subsequent receive call on a receiver will return a disconnected error.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.BusIntoIter.html'
                                  title='bus::BusIntoIter'>BusIntoIter</a></td>
                           <td class='docblock-short'>
                                <p>An owning iterator over messages on a receiver.
This iterator will block whenever <code>next</code> is called, waiting for a new message, and <code>None</code> will
be returned when the corresponding bus has been closed.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.BusIter.html'
                                  title='bus::BusIter'>BusIter</a></td>
                           <td class='docblock-short'>
                                <p>An iterator over messages on a receiver.
This iterator will block whenever <code>next</code> is called, waiting for a new message, and <code>None</code> will
be returned when the corresponding channel has been closed.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.BusReader.html'
                                  title='bus::BusReader'>BusReader</a></td>
                           <td class='docblock-short'>
                                <p>A BusReader is a single consumer of Bus broadcasts.
It will see every new value that is passed to <code>.broadcast()</code> (or successful calls to
<code>.try_broadcast()</code>) on the Bus that it was created from.</p>
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "bus";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script defer src="../search-index.js"></script>
</body>
</html>